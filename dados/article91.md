Title: Trustworthy Reputation for Federated Learning in O-RAN Using Blockchain and Smart Contracts

Abstract:
This paper proposes a blockchain-enabled framework to enhance trust, transparency, and collaboration in Open Radio Access Network (O-RAN) infrastructures through Federated Learning (FL). Traditional O-RAN architectures and centralized machine learning approaches face challenges when integrating multi-vendor environments, primarily due to lack of trust, proprietary data concerns, and limited interoperability. Our solution transitions from implicit trust, where the reliability of contributions is assumed, to explicit trust, where reputation is verifiably established on-chain. We introduce a blockchain-based reputation mechanism that evaluates the accuracy, integrity, and quality of participants’ model updates within the FL process. Smart contracts automate critical tasks-such as participant registration, model update verification, and reputation scoring-ensuring that data inputs directly influence accountability in a tamper-proof, transparent manner. By deploying the framework on a scalable Layer 2 blockchain (Polygon) testnet and proposing the use of a blockchain oracle within this architectural framework for secure off-chain computations, this work focuses on a conceptual architectural approach by aligning with O-RAN’s architecture to propose and deploy a Decentralized Application (DApp) on the blockchain. The proposed framework emphasizes a conceptual design over performance optimization and is structured to naturally benefit from ongoing improvements in blockchain scalability, which may reduce latency and enhance operational efficiency over time. Smart contracts for crucial processes and reputation calculation are included within our proposed DApp. The implementation of this work is publicly accessible https://github.com/farhanajaved/Reputation_O-RAN.

Illustrative Image
Published in: IEEE Open Journal of the Communications Society ( Volume: 6)
Page(s): 1343 - 1362
Date of Publication: 10 February 2025 
Electronic ISSN: 2644-125X
DOI: 10.1109/OJCOMS.2025.3540159
Publisher: IEEE
Funding Agency:
CCBY - IEEE is not the copyright holder of this material. Please follow the instructions via https://creativecommons.org/licenses/by/4.0/ to obtain full-text articles and stipulations in the API documentation.
SECTION I.Introduction
The rapid evolution of mobile networks towards 5G and beyond has made more flexible and interoperable solutions necessary [1]. The Open Radio Access Network (O-RAN) has evolved as a paradigm shift from traditional, proprietary RAN architectures to a more open and disaggregated framework [2]. O-RAN enables flexible, multi-vendor, data-driven networks through disaggregation, intelligence, virtualization and programmable white-box hardware. It reorganizes the 3rd Generation Partnership Project (3GPP) stack into Radio Units (O-RU), Distributed Units (O-DU) and Centralized Units (O-CU), bringing functionality closer to users and enabling resource sharing to reduce costs. By enabling multiple service providers to collaborate and seamlessly integrate components from different vendors, O-RAN promotes vendor diversity, innovation and cost efficiency [3].

The O-RAN Alliance has created specifications for O-RAN that focus on two key principles: openness and embedded intelligence [4]. O-RAN aims to overcome vendor lock-in by decoupling network processing layers from proprietary hardware and utilizing a common, open cloud infrastructure. A key feature of O-RAN is the integration of native intelligence into the radio access network, with Artificial Intelligence (AI) and Machine Learning (ML) playing a central role [5]. The application of AI/ML in this context reduces the need for manual intervention by automating the analysis of large data sets to identify problems and support decision making [6], [7]. This improvement leads to predictive capabilities that facilitate proactive action, resulting in significant time and cost savings.

In practice, AI and ML algorithms are used for various network functions, such as predicting resource utilization, optimizing network performance, etc. These applications require the training of fast and secure ML models [7], [8]. However, the use of AI/ML at scale within O-RAN leads to challenges in terms of data privacy and collaboration between multiple service providers. Traditional centralized ML approaches reach their limits, e.g., when transferring locally collected data to a central server and extended model training times. The sharing of raw data between different entities raises concerns about proprietary information, data privacy in shared cloud environments and regulatory compliance [4], [7]. Therefore, an approach that enables collaborative intelligence without compromising data privacy is essential.

However, addressing data privacy alone does not solve the broader challenge of trust and accountability in a multi-vendor O-RAN environment. Even if providers retain their data locally, low-quality or malicious updates can still undermine overall model performance. Without a transparent mechanism to verify and reward reliable contributions, federated training efforts can suffer from hidden vulnerabilities. Ensuring that each stakeholder’s updates are both credible and auditable is thus vital for collaborative intelligence to be truly effective in O-RAN.

Federated Learning (FL) has emerged as a promising solution to these challenges by enabling decentralized model training [4], [7]. FL is a distributed ML framework that enables multiple entities, e.g., service providers, to collaboratively train a shared AI/ML model while keeping their data decentralized [4], [6]. This approach improves privacy by allowing each participant to retain their data local. In FL, each service provider, called a client, independently trains a local model on its own dataset. These local model updates are then sent to a central aggregator, possibly managed by another service provider or a neutral entity, which combines them into a global model. This global model is then distributed back to the clients so that they can train it further in subsequent rounds. This maintains a cyclical process that refines the accuracy and effectiveness of the model over time. In the context of Open RAN, FL enables different service providers to engage in collaborative learning for different use cases without sharing their proprietary data. For example, they can jointly improve resource utilization prediction models to improve the overall performance of the network while maintaining data privacy [6], [7]. In FL, where data contributions come from different entities, e.g., Mobile Network Operators (MNOs), maintaining trust and transparency in a multi-vendor environment is a challenge. Blockchain has been introduced as an additional layer of trust, the potential of which is being explored by several standardized organizations in the telecommunications sector, e.g., TM Forum [9], CAMARA API [10] and the European Telecommunications Standards Institute (ETSI) group [11], [12], [13]. These groups are actively investigating how blockchain can improve telecommunications infrastructures.

To address aforementioned problems, this paper presents an architectural framework for the integration of blockchain into O-RAN environments to improve FL, focusing on the development of a blockchain-based reputation mechanism. This framework prioritizes conceptual design and its structure allows it to inherently take advantage of future blockchain scalability developments that may lower latency and improve operational efficiency over time for performance optimization [14]. Using blockchain as a decentralized and immutable ledger, the framework ensures verifiable records of all model contributions and updates, which increases trustworthiness.

Additionally we propose a Decentralized Application (DApp) consisting of key smart contracts deployed on the blockchain-crucial for maintaining indisputable record-keeping and reliability within FL processes [15], [16], [17]. These proposed smart contracts within this DApp assist the overall architecture to automate critical processes such as the registration of clients and aggregator and manages their interactions via smart contracts. These smart contracts are an essential part of the reputation mechanism as they accurately record and evaluate the contributions of each participant.

Therefore, the main key contribution of this study can be listed as follow:

The primary key contribution of this work is the proposal of an architectural framework that integrates blockchain to shift from explicit to implicit trust models, thereby enhancing collaboration in federated learning (FL) within a multi-vendor environment [5]. This framework addresses the lack of inherent trust among individual service providers by incorporating a blockchain-based trust layer. The paper outlines how FL can be implemented within the O-RAN architecture, using blockchain and smart contracts.

We introduce a DApp composed of smart contracts designed to handle critical processes such as onboarding, sharing performance parameters, and computing reputation based on client contributions. This includes specialized smart contracts for managing reputation scores, aiding aggregators in assessing and selecting top-performing clients in each FL round. Additionally, we propose integrating a decentralized oracle to connect blockchain smart contracts with off-chain computing resources [18], [19], [20]. By securely interfacing on-chain logic with external computations submitted by clients, the framework ensures that data quality and reliability significantly affect model outcomes.

Another key contribution is the implementation of the proposed DApp on an L2 blockchain testnet (specifically, Amoy), an approach not discussed in the literature. This involves deploying the smart contracts on a Layer 2 testnet, closely mirroring real-world conditions while maintaining Layer 1 security. Leveraging Polygon’s testnet [21] enhances transaction throughput and reduces costs [14]. By utilizing an L2 blockchain, the proposed framework meets the critical needs of high transaction speed and cost-effectiveness without sacrificing security. We further provide a comprehensive evaluation of gas usage and transaction latency, clarifying operational costs and performance impacts.

This paper is structured as follows: Section II reviews related work on blockchain in FL and O-RAN environments. Section III outlines the proposed framework, focusing on smart contract integration to enhance trust in decentralized networks. Section IV presents the experimental evaluation and provides a discussion. Finally, Section V concludes and provides future research direction.

SECTION II.Related Work and Our Contributions
In this section, we review existing literature on the integration of blockchain technology with FL and O-RAN, focusing on how blockchain has been applied in these domains and the development of reputation mechanisms. We first discuss the use of blockchain and reputation mechanisms in FL to enhance security and trust. Then, we explore the integration of blockchain within O-RAN, highlighting efforts to improve security, resource management, and collaboration. This review aims to identify gaps in the current research that our work seeks to address.

In terms of Blockchain and reputation mechanisms in FL, Blockchain has been widely integrated with FL due to its ability to provide a decentralized, tamper-proof ledger that enhances trustworthiness in distributed systems [31], [32], [33], [34], [35]. By securely recording model updates and transactions, blockchain improves the security and privacy of the FL process. This integration helps mitigate issues related to single points of failure and centralized trust, which are inherent in traditional FL setups. In decentralized networks like FL, reputation mechanisms are crucial for managing trust among participants, especially in environments where nodes may behave maliciously or unreliably. Blockchain has been employed to implement such reputation mechanisms due to its transparency and immutability [22], [23], [24], [36], [37], [38]. Authors in [25] proposed methods to manage malicious activity and improve transparency to ensure fair distribution in FL systems. In [26], an improved reputation evaluation algorithm for FL on blockchain networks was introduced, aiming to enhance worker selection and collaboration by mitigating the impact of malicious evaluations and promoting fair assessment for new nodes. Additionally, authors in [27] proposed a blockchain-based trust and reputation service specifically designed for decentralized marketplaces.

The combination of cryptographic techniques with reputation mechanisms in FL networks has also been explored to promote decentralization and enhance security. For example, authors in [28] investigated this integration to improve trust among participants. Techniques such as homomorphic encryption have been proposed to secure model aggregation processes, and zero-knowledge proofs have been utilized to verify the correctness of model updates without compromising data privacy [29], [39]. Furthermore, authors in [29] and [30] explored how blockchain enhances the privacy and reliability of nodes in FL, contributing to more secure network interactions. On the other hand, the integration of blockchain within O-RAN has been explored to enhance various aspects of these systems, including security, resource management, and collaboration among multiple providers. Authors in [40] presented work that uses blockchain to facilitate the exchange of resources between mobile operators.

In [41], a blockchain-based decentralized Zero-Trust framework named TrustORAN was introduced to enhance the security and resilience of O-RAN systems in the context of 6G networks. This framework incorporates both private and public blockchains to ensure the verification and authentication of extensible applications (xApps) used in O-RAN, preventing unauthorized access and ensuring a high level of network security and trustworthiness. Authors in [42] explored the integration of blockchain within the O-RAN framework for enhancing resource management and sharing in 6G networks, addressing challenges such as spectrum scarcity and the high-performance demands of 6G. Furthermore, authors in [43], [44] proposed integrating Quantum Key Distribution (QKD) and Blockchain-based Self-Sovereign Identity (SSI) within the O-RAN framework for 6G networks, aiming to enhance security and robust identity management. They presented a multi-layered architecture that utilizes the capabilities of quantum security and blockchain technology to ensure secure operations across O-RAN layers. In addition, authors in [45] examined the integration of blockchain with O-RAN for enhancing security, privacy, and decentralized decision-making in cellular networks. They demonstrated how blockchain facilitates secure, transparent communication and resource management between distributed and centralized units, leveraging smart contracts to adapt network operations to dynamic conditions. Privacy-preserving decentralized RAN architectures and cross-border blockchain-based connectivity solutions have also been explored in [46], [47], [48].

Despite these advancements, the integration of blockchain-based reputation systems into collaborative environments within O-RAN, particularly at the interface with FL, remains under-researched. This gap is significant because the open architecture of O-RAN, involving multiple providers, introduces trust-related challenges that need to be addressed to ensure secure and efficient collaboration. To address this gap, we propose a blockchain-enabled framework that utilizes smart contracts to facilitate a collaborative FL environment in O-RAN. Unlike previous works, our system integrates blockchain with FL to enhance trust, transparency, and collaboration among O-RAN providers. Our approach focuses on developing a blockchain-based reputation mechanism within O-RAN environments to augment FL. By leveraging blockchain as a decentralized and immutable ledger, our framework ensures that all model contributions and updates are verifiable, thereby enhancing trustworthiness. The deployment of a DApp on the blockchain is crucial for maintaining indisputable record-keeping and reliability within FL processes [15], [17]. Moreover, the framework automates critical processes such as client and server registration and manages their interactions through smart contracts, which are integral to the reputation mechanism by accurately recording and evaluating each participant’s contributions.

In contrast to earlier studies that primarily rely on explicit trust models or centralized authorities, the main contribution of this work is the introduction of an architectural framework that utilizes blockchain to shift from explicit to implicit trust models, thereby bolstering collaboration in FL within multi-vendor ecosystems [5]. By integrating a blockchain-based trust layer, this framework addresses the issue of limited inherent trust among various service providers. Furthermore, it demonstrates how FL can be implemented in the O-RAN architecture using both blockchain technology and smart contracts, distinguishing it from existing literature that does not fully consider such trust transitions.

Building on this framework, we present a DApp consisting of smart contracts that manage critical procedures, including the onboarding process, the exchange of performance parameters, and the calculation of reputation tied to client contributions. These smart contracts are specifically tailored to maintain reputation scores, enabling aggregators to effectively assess and select top-performing clients in each FL round-a dimension not extensively detailed in prior research. Additionally, we propose the integration of a decentralized oracle to connect blockchain smart contracts with off-chain computational resources. This step is crucial given that some computations require significant processing power and thus must be performed off-chain [18], [19], [20]. By securely linking these off-chain computations, our approach ensures that data quality and reliability substantially influence the accuracy and outcomes of the aggregated models.

Lastly, in contrast to conventional deployments, we implement the proposed DApp on a Layer 2 (L2) blockchain testnet known as Amoy, an environment that has not received extensive attention in the literature. The associated smart contracts are deployed on this L2 testnet to approximate real-world operational conditions while retaining the security guarantees found in Layer 1. Leveraging Polygon’s testnet, for instance, allows the architecture to achieve improved transaction throughput and cost efficiency [21]. By positioning smart contracts on an L2 blockchain, we address the need for rapid transaction speeds and minimized operational costs without compromising security [14]. Finally, we present an in-depth analysis of gas consumption and transaction latency within this blockchain-driven setup, which is pivotal for understanding the operational expenditures and their implications for overall system performance.

Table 1 focuses specifically on literature that applies blockchain-based reputation mechanisms within FL. However, to our knowledge, no existing study combines FL, blockchain, and reputation specifically in O-RAN environments. Although various works explore related architectures or techniques, none provide a reputation mechanism for ensuring trustworthy FL clients in an O-RAN context. In addition to highlighting these gaps, the table underscores our contributions-most notably, the use of a PoS-based blockchain architecture tailored for O-RAN and a performance analysis conducted on a live testnet, which offers more realistic insights than purely private or simulation-based blockchains.

TABLE 1 Comparison of Blockchain-Based Reputation Mechanisms in FL: Methods, Metrics, and Differences With Our Work
Table 1- Comparison of Blockchain-Based Reputation Mechanisms in FL: Methods, Metrics, and Differences With Our Work
Although Table 1 outlines several blockchain-based FL frameworks and how our approach differs, a direct numerical comparison remains difficult. Many prior works employ private blockchains or omit crucial on-chain metrics such as gas usage, block size, or concurrency-induced latency. They also vary in consensus mechanisms (e.g., PBFT, PoT, or no blockchain) and do not typically test large-scale concurrency. By contrast, our framework leverages a PoS sidechain (Polygon Amoy) specifically for an O-RAN setting and is deployed on a live testnet. This environment more closely approximates real-world conditions than private blockchains, where minimal external transaction activity can skew performance results.

Our approach offers three notable advantages over existing solutions. First, we compute reputation scores off-chain, merging the results into a single on-chain transaction at the end of each FL round, rather than updating each client’s reputation individually. For instance, in a setting with 50 clients over 50 FL rounds, a naive approach would require 50×50=2,500 on-chain updates. Instead, we employ one transaction per round (i.e., 50 total), thereby avoiding 2,450 additional updates and substantially reducing both gas costs and confirmation times. Second, by using a PoS sidechain, we achieve lower latency and faster block finality than many PoW-based systems, which we empirically confirm by measuring gas usage, block size, transaction count, and concurrency-induced latency for up to 50 FL clients. Third, our work is the first to integrate blockchain-based FL into an O-RAN context on a live testnet, capturing practical deployment considerations-such as external transaction load, block parameters, and concurrency effects-that are rarely addressed in private or simulation-oriented studies.

SECTION III.Blockchain-Enabled Reputation Mechanism for Trustworthy Federated Learning in O-Ran
This section first explains the context of ML in O-RAN and the requirements of the framework for use cases. Then, the proposed FL Blockchain DApp (BC-DApp) and its components are explained.

A. ML Framework Within O-RAN Architecture
The ML framework within the O-RAN architecture can be implemented in different configurations to accommodate different operational scenarios. These configurations include multiple entities such as the Non-RT RIC and the Near-RT RIC, each hosting different functions – ML Training Host (MTH) and ML Inference Host (MIH). Depending on the specific requirements and network structure, ML training and ML inference can take place within the same RIC or be distributed across different RICs. This enables flexible integration tailored to effectively optimize RAN performance. This versatility ensures that machine learning can be effectively adapted to different network environments and requirements [4]. In the O-RAN architecture, ML training and inference activities are assigned to different entities, mainly Non-RT RIC and Near-RT RIC, which correspond to the management plane and the RAN domain, respectively. Three primary deployment scenarios are outlined in the O-RAN AI/ML documents [6], [49]: Option 1 places both the ML Training Host (MTH) and the ML Inference Host (MIH) in the Non-RT RIC; Option 2 positions the MTH in the Non-RT RIC while the MIH is in the Near-RT RIC; and Option 3 places the MTH in the SMO and the MIH in the Non-RT RIC.

Our proposed work builds on the MonB5G project,1 which investigates the management of 5G networks by FL. The use case of this project, as described in [50], involves the prediction and dynamic allocation of CPU resources. In our deployment scenario, shown in Figure 1, the training host labeled as FL Training Host is located in the Service Management and Orchestration (SMO) and the ML inference host labeled as FL inference host is located in the Non-Real-Time RIC, which corresponds to option 3. This setup was chosen because the use case does not require near real-time operations, as discussed in [50], which allows a more deliberate timeframe for processing. We consider two different types of service providers that interact with our proposed DApp.

Each Client Service Provider (CLSP) operates its own FL Training Host via SMO-Client. This host is responsible for training local models based on the data available at the edge. The FL Inference Host on the CLSP side then uses the trained models to make local decisions.

The FL aggregator, which is located in the SMO-Aggregator part of the Aggregator Service Provider (AGSP), is responsible for aggregating the updates received from all FL training hosts across different CLSPs. This aggregator optimizes the global model by integrating various insights from across the network, which are then fed back to the individual CLSPs for further training or inference.

FIGURE 1. - Proposed Framework: Functional blockchain-enabled O-RAN architecture for trustworthy FL using smart contracts.
FIGURE 1.
Proposed Framework: Functional blockchain-enabled O-RAN architecture for trustworthy FL using smart contracts.

Show All

Our framework in Figure 1 integrates the blockchain as an additional layer of trust and moves from explicit to implicit trust models. This evolution is crucial in a multi-vendor environment, as individual service providers do not necessarily inherently trust each other. By using the blockchain, every contribution made by a CLSP is recorded immutably, which ensures verifiable transparency in the model training process. This transparency is essential to build mutual trust between participants [11], [13]. Most importantly, the framework incorporates a reputation mechanism that assesses the quality of contributions from each client in each round. This reputation score is calculated based on the accuracy of the data provided for training the model after each FL round. High-quality contributions increase a provider’s reputation; conversely, underperformance or faulty data submissions result in lower scores. In particular, only the best 90% of the best performing clients are selected for the following rounds. This mechanism is important to maintain the integrity of the system and ensure that all participants are accountable for their contributions [36]. Finally, every service provider, whether CLSP or AGSP, integrates a chainlink adapter into its infrastructure. The chainlink adapter acts as a bridge between the off-chain environment and the blockchain, enabling secure and reliable data transfer. In our framework, CLSPs use the Chainlink Adapter to send their NMSE values to the decentralized oracle network. Both CLSPs and AGSPs are connected to the Chainlink oracle via interfaces known as the Chainlink Adapter Interface (CAI), highlighted as CLSP-BC-CAI and AGSP-BC-CAI respectively.

B. Proposed Federated Learning Blockchain Decentralized Application (BC-DApp)
A Blockchain DApp (BC-DApp) is deployed on a blockchain and managed by a network of nodes within a decentralized network. It works with the blockchain. The architecture of a BC-DApp includes smart contracts, which are crucial for managing interactions. Below we explain the proposed smart contract for FL BC-DApp and the workflow.

1) Proposed Smart Contracts
The BC-DApp consists of several smart contracts, which are explained below:

1) Registration on the DApp:
In the proposed BC-DApp, the registration process initiated by the AGSP and is central to the management of participation in the DApp. This process begins at the frontend, where the participants first interact with the framework. Through this interface, the participants gain access to the DApp, which forwards them to the necessary access control mechanisms. Primarily, every AGSP undergoes a validation check through an access control smart contract. This verification process assesses whether the AGSP has already been registered and whether its registration is still valid. If the AGSP is already registered and the registration is still valid, it proceeds with the existing credentials through the Access Credential Interface (ACI), as highlighted in the figure labeled ASP-BC-ASI. If not, a new Ethereum address and a private key are generated and stored in the digital wallet. After successful validation and to start the FL process, the system dynamically generates a new smart contract, registrationClient.sol, which is specifically tailored to this session. The newly created smart contract registrationClient.sol is then used by the AGSP to open the registration phase for CLSPs. In this phase, clients can either register for the first time or validate their existing registrations. Like AGSP, CLSPs whose previous registrations are still valid will continue with their existing Ethereum addresses and private keys. Those who require a new registration will generate new credentials.

As part of the registration, Ethereum addresses and private keys are either revalidated or newly generated, depending on the participant’s existing status. These credentials are securely stored in each participant’s credential wallet, maintaining control over their digital identity and transactions within the DApp. CLSPs register using the registerAsClient function in the smart contract, which ensures that all participants are valid and authorized. Each successful registration of a client triggers a ClientRegistered event within the blockchain. This serves as a transparent and immutable record of the client’s onboarding, facilitating traceability and accountability within the system.

2) Submission of Performance Parameter on DApp:
In our framework, the smart contract performanceSubmission.sol is crucial for managing the submission and recording of model performance metrics by CLSPs participating in different training rounds. The smart contract is initiated once the registration is completed and the CLSPs are ready to share their local performance metrics with the server. In our use case presented in [50], the local weights are the parameters of a prediction model that each CLSP develops independently. These weights are derived from training the model with locally available data, which includes various streaming metrics such as bandwidth utilization, server load and user engagement. The local weights capture the learned behavior and characteristics of the data specific to each provider’s network. They are critical for predicting future network resource needs, such as CPU utilization, based on current and historical streaming traffic patterns. Essentially, the local weights allow each CLSP to make informed predictions about resource allocation to ensure efficient and uninterrupted video streaming.

To evaluate the performance of these predictive models, we use the Normalized Mean Squared Error (NMSE) as a performance metric. Recording the NMSE values on the blockchain provides a verifiable, immutable record of model accuracy, fostering an accountable and transparent environment essential for enhancing trust and ensuring the integrity of the FL process across all participating CLSPs. Given this context, the performanceSubmission.sol contract is designed to support up to fifty FL rounds based on the structured phases of the learning process. The contract allows CLSPs to submit their NMSE values for each FL training round via the submitNMSE function.

To securely and accurately bring off-chain performance metrics on-chain, this smart contract is linked with fetchOracle.sol. In our framework, CLSPs use the Chainlink Adapter to send their NMSE values to the Chainlink decentralized oracle network. The Chainlink oracle then relays this data to a mock smart contract called fetchOracle.sol, which serves as an intermediary that fetches the NMSE data and makes it accessible to our performanceSubmission.sol smart contract. This integration with Chainlink ensures that off-chain performance metrics are securely and accurately brought on-chain, maintaining data integrity and trustworthiness. By utilizing the Chainlink network and the fetchOracle.sol smart contract, we aim to bridge the gap between off-chain computations (performed outside the blockchain) and on-chain smart contracts (transactions or interactions that result in a transaction on the blockchain).

When an NMSE value is submitted, the contract first verifies that the submission is within the allowed range of rounds and that the CLSP has not previously submitted for that round. If the submission is successful, the client’s address and the performance metric (NMSE) submitted are recorded on the blockchain. This action triggers the event nmseSubmitted, which serves as a transparent log on the blockchain and marks the submission.

The contract also restricts the reading of detailed performance information to the AGSP that initiated the FL process. The AGSP, defined when the contract is deployed, is the only entity authorized to retrieve the complete list of submitted performance metrics and the corresponding client addresses for a given round. Our architectural framework and DApp are designed with flexibility in mind, therefore our smart contract and framework can be adapted to suit different FL scenarios.

3) Calculation of Reputation Score:
In our framework, reputationCalculation.sol smart contract is essential for managing reputation scores and selecting top performers among the CLSPs participating in different training rounds. The smart contract is initiated as soon as the first CLSP successfully submits a performance metric (NMSE), signaling the start of the reputation calculation process. In the context of our use case presented in [50], maintaining an accurate and fair reputation system is crucial for incentivizing CLSPs to contribute high-quality models. The reputationCalculation.sol contract serves this purpose by evaluating each CLSP’s contributions based on their submitted performance metrics. The initializeScores function is pivotal at the beginning of the learning process or each new phase within the framework. It resets the reputation scores of all registered clients to zero, ensuring a fair starting point for all participants as they commence or restart the learning process. The updateScores function updates the reputation of each client based on the accuracy of their contributions, measured by the NMSE values. The reputation score Ri for the i -th client is recalculated using the formula:
Ri=1×1018NMSEi+ϵ(1)
View SourceRight-click on figure for MathML and additional features.where ϵ=10 is a small constant used to stabilize the calculations and avoid division by zero. This method ensures that clients with lower NMSE scores—indicating higher accuracy and reliability—receive higher reputation scores. After updating the scores, the selectTopPerformers function identifies and lists the top 90% of performers based on their updated reputation scores for next round. This selection is crucial for recognizing and potentially rewarding the most reliable and accurate participants in the system. By focusing on these top performers, the framework encourages competition and drives overall improvement in the accuracy and reliability of the models contributed. Every function and transaction within the reputationCalculation.sol contract is recorded on the blockchain (see Algorithm presented in 1), ensuring that all operations are transparent and immutable. This blockchain integration guarantees that each participant’s reputation is constantly updated and accurately reflects their contributions. The immutability of blockchain entries ensures that no alterations can be made once a reputation score has been recorded, providing a trustworthy and tamper-proof system.

2) Workflow
Finally, Figure 2 shows the sequence diagram of an FL, integrated with blockchain and smart contracts. The workflow of our proposed framework starts upon successful authentication. The SMO-Aggregator launches the FL process and, using the smart contract (registrationClient.sol), initiates the registration phase for SMO-Clients, which are part of the CLSPs.

FIGURE 2. - Sequence Diagram: Reputation Calculation in FL for O-RAN. The diagram details the process from client registration to reputation calculation and iterative rounds, using blockchain and smart contracts.
FIGURE 2.
Sequence Diagram: Reputation Calculation in FL for O-RAN. The diagram details the process from client registration to reputation calculation and iterative rounds, using blockchain and smart contracts.

Show All

Algorithm 1: - Reputation Calculation Smart Contract
Algorithm 1:
Reputation Calculation Smart Contract

Show All

The SMO-Clients, encompassing the FL Training Host and FL Inference components, interact with the BC-DApp to register. Following registration, the SMO-Aggregator sends a training request along with the initial global model to the SMO-Clients via the FL Training Host. Each SMO-Client performs local training on their respective datasets and computes the NMSE of their locally trained predictive models. To submit their model updates, including weights and NMSE values, SMO-Clients use the smart contract (performanceSubmission.sol) to send these values to the blockchain.

Upon receiving an NMSE value via the submitNMSE function, the performanceSubmission.sol contract verifies the submission’s validity and records the SMO-Client’s address and NMSE on the blockchain. Simultaneously, the reputationCalculation.sol smart contract updates each SMO-Client’s reputation score based on their NMSE values, using a formula that rewards lower NMSE with higher reputation. After each round, the selectTopPerformers function identifies the top 90% of performers, who are then selected to contribute to the global model in the next round. This mechanism promotes high-quality contributions and continuous improvement among SMO-Clients.

The SMO-Aggregator aggregates the model updates from the selected top performers by computing a weighted average of their submitted model NMSE values, with NMSE proportional to their reputation scores. The updated global model is then distributed back to the SMO-Clients, and this update is confirmed with an acknowledgment recorded on the blockchain to ensure all parties are synchronized with the latest model state.

The FL round concludes with an end signal, and the system loops back to begin the next cycle of model distribution and training. This looping mechanism fosters continual learning and refinement among the SMO-Clients and the SMO-Aggregator, facilitated through the BC-DApp.

SECTION IV.Deployment and Evaluation
This section outlines our simulation setup and evaluation strategy for testing Ethereum-based smart contracts, as detailed in Section III. We have implemented our smart contracts using Kubuntu 22.04.3 LTS, complemented by 32 GB DDR4 RAM to enhance processing capabilities. The development framework used is Hardhat 2.22.4, which facilitates the development of Ethereum-based applications, and the smart contracts are developed using Solidity v0.8.0 to ensure secure and efficient coding as detailed in Table 2.

TABLE 2 Simulation System for FL DApp
Table 2- Simulation System for FL DApp
For our simulations, we utilize the Polygon testnet Amoy, a L2, which operates on top of the Ethereum mainnet to offer faster transaction speeds and lower gas costs. This test environment mirrors the conditions of the Polygon mainnet, allowing for a realistic assessment of network responsiveness and performance. The choice of Amoy is strategic, enabling extensive testing of smart contracts before deployment in live settings. The simulation involves 51 External Owned Accounts (EOAs) – 50 FL clients and 1 server – to simulate different types of interactions within the network. These interactions are demonstrated through three phases of operations: registration of clients, submission of NMSE value, and calculation of reputation scores. Each test was run over 10 iterations to ensure robustness. An essential component of our setup is the fetchOracle from Chainlink,2 an oracle contract that, along with a custom external adapter, enables the integration of blockchain smart contracts with external data sources. This setup allows a Chainlink node to retrieve client IDs and their associated NMSE from a predefined mock API, format this data appropriately, and feed it into the smart contract. This process is critical for ensuring that the smart contract can operate with external data in a simulated environment, which is ideal for development and testing.

A. Relevant Blockchain Network Parameters
A transaction on the Amoy testnet is a digitally signed instruction from an externally owned account. After submission, these transactions are validated and added to the blockchain through consensus process. Several critical network parameters influence this process on Amoy which are explained as follow:

Gas Price: In blockchain networks such as Polygon, the “Gas Price” refers to the cost per unit of computing effort required to perform transactions or execute smart contracts on the network. This price is denominated in gwei, which is a smaller denomination of the network’s native cryptocurrency (1 gwei =10−9 ETH for Ethereum-based networks like Polygon). Gas prices are determined by supply and demand dynamics within the network’s transaction market. Users bid a gas price to have their transactions processed by miners or validators, who prioritize transactions offering higher gas prices for inclusion in the blockchain. This mechanism helps regulate the network’s computational resources by incentivizing validators to prioritize transactions that contribute more economically. High network congestion typically leads to higher gas prices as users compete to get their transactions processed faster. Conversely, lower activity on the network can result in lower gas prices.

Block Size: In blockchain networks such as Polygon, “Block Size” refers to the physical limit of data storage capacity for each block in the blockchain. Each block in a blockchain can contain a finite number of transactions, with the size generally measured in bytes. The block size limit is a critical parameter as it directly influences the network throughput and transaction speed. A larger block size allows more transactions to be included in each block. However, increasing the block size can also lead to longer propagation times.

Transaction Count: This parameter refers to the total number of individual transactions that a single block in the blockchain can hold and successfully process. This count is crucial for understanding the network’s throughput. The number of transactions per block can vary widely and is influenced by factors such as the block size and the complexity of the transactions. For example, simpler transactions, which require less processing power and lower gas fees, might allow for a higher transaction count per block compared to more complex interactions like those executing smart contracts, which consume more resources.

B. Evaluations Metrics
We present the evaluation of smart contracts as described in Section III-B1, focusing on the execution of functions within FL DApp implemented on the Polygon Testnet blockchain involving different smart contracts. These smart contracts are an essential part of managing state transitions, data storage and computation within the FL DApp. When evaluating the performance of these smart contracts, two metrics are particularly important: latency and gas consumption, which we explain as follows:

1) Gas Used
Ethereum enables the execution of smart contracts through the Ethereum Virtual Machine (EVM). The EVM is a virtual machine that interprets a low-level, stack-based bytecode language that enables it to perform various computational tasks necessary for the processing of smart contracts. At the heart of EVM functionality are the opcodes, i.e., basic instructions that control the operations of the virtual machine. Function calls within smart contracts are central to the execution logic and include operations such as computations, data retrievals, and conditional checks. When a function is called, it can invoke a number of opcodes depending on the type of operation it performs. These opcodes can either read or write the status of the blockchain and thus significantly influence how the contract behaves and interacts with the data. One of the most important opcodes in connection with function calls is SSTORE (Storage Store), which is used to store data in the status of the blockchain. This opcode is crucial because it writes data to the ledger, permanently changing the state of the contract. Due to its role in changing the blockchain, SSTORE is considered a gas-intensive operation. The high gas cost reflects the computational overhead and the need to reach consensus across the network to validate the change. Each transaction involving these opcodes requires gas, a unit that measures the computational effort required to execute operations on the blockchain. In our tests, after the successful execution and confirmation of a transaction, we generate a transaction receipt as: const gasUsed = receipt.gasUsed;. This receipt contains a detailed record of the transaction, encapsulating key information such as the execution status and all events that were triggered during the process. A crucial element of this receipt is gasUsed, which indicates the actual amount of gas consumed during the transaction. This metric is crucial as it reflects the computational resources used to execute the transaction and provides insights into the operational complexity of the smart contract’s functions within our FL DApp framework.

2) Transaction Latency
Latency is a critical performance metric in blockchain systems. It measures the time it takes from the transmission of a transaction to the network until it is fully confirmed. This metric is used to evaluate the responsiveness of the network and serves as a key indicator of overall performance, especially in the execution of smart contracts. In our test script, we measure the latency by calculating the difference between the timestamp of the block containing the confirmed transaction (Tconfirmed) and the timestamp when the transaction was originally submitted (Tsubmitted) , i.e.,
L=Tconfirmed−Tsubmitted.(2)
View SourceRight-click on figure for MathML and additional features.

Above calculation provides a direct measure of the overall latency as the time it takes to include and confirm the transaction in a block. The Amoy testnet, which is very similar to the Polygon mainnet, is used in this analysis to evaluate transaction processing under test conditions. By using blockchain-native timestamps, this approach allows us to capture the overall response time of transactions in the network. To investigate how these factors affect latency, we perform sequential (i.e., for registration of CLSPs) and concurrent transactions (i.e., NMSE submission by each CLSP) for the main functions of each smart contract in our FL DApp, as shown in Table 3. By simulating interactions from multiple accounts, we can observe how the network handles multiple transactions and how this affects overall latency.

TABLE 3 Gas Used During Initialization and Post-Initialization Phases for Each Function
Table 3- Gas Used During Initialization and Post-Initialization Phases for Each Function
C. Gas Consumption
In Table 3 we analyze the gas usage of the most important functions within our smart contracts, categorized into the phases ‘initialization’ and ‘post-initialization’. These phases reflect different states of data interaction within the Ethereum Virtual Machine (EVM) and influence the gas costs associated with smart contract operations. During the ‘initialization phase’, functions that require the creation or modification of new data storage locations incur higher gas costs. This is primarily due to the need to allocate and initialize storage space. An example is the function registerAsClient from the contract registrationClient.sol, where the initial registration of a CLSP client requires the creation of new entries in a mapping, which increases the initial gas consumption, and which is only executed once. The ‘post-initialization’ phase, on the other hand, contains interactions with data that has already been initialized. The operations here are generally more economical and involve updates to existing data structures. In the contracts performanceSubmission and ReputationCalculation, for example, functions such as submitNMSE and updateScores work in both phases. Initially, these functions initialize the data structure, which leads to higher gas costs. Subsequent accesses to update scores or submit new NMSEs are cheaper because they use previously established data pathways within the smart contract. Below we explain in detail the gas used for each function in our smart contract:

1) Gas Used for Registration of Each Client
The contract is used to register clients each time the function registerAsClient() is called. According to our observations, this operation consistently consumes about 43,464 gas per transaction. To understand this consistent gas consumption, it is important to examine how the EVM processes this function, focusing in particular on the low-level operations known as opcodes, with a focus on the SSTORE opcode, which is responsible for writing data to the blockchain’s storage [51]. Writing to the blockchain is inherently gas-intensive, as it modifies the persistent state of the blockchain, which must be replicated on all nodes in the network to ensure the integrity and synchronization of the decentralized ledger. The SSTORE opcode is one of the most costly operations in EVM due to this requirement. In the registerAsClient() function as shown in Table 3, each call performs a write operation by adding the address of a new client to the registeredClients mapping. When a client registers for the first time, the storage slot corresponding to its address is initially not initialized (by default it is zero). By setting the address of each client, the storage value is changed from zero to a non-zero value, resulting in a total gas cost of 43,464 through this write operation. This operation effectively adds a new client to the blockchain by initializing its unique storage slot.

2) Gas Used for Submission of NMSE
The Table 3 shows the gas used for the function submitNMSE() in performanceSubmission.sol. When a client interacts with the submitNMSE() function for the first time (“initialization” phase as explained in Table 3) to submit a weight for a particular round, a higher gas cost is observed, a total of 113,394 gas. This first interaction is crucial because it initializes several storage structures for this round. First, an array initialization is performed. The contract initializes an array into which the address of the first client is inserted. Secondly, the function maps the entries: it sets and records the weight of the client in the assigned array. Initializing these storage variables incurs a higher gas cost due to the way the EVM handles storage writes. Writing to a storage slot that has not yet been used (from zero to non-zero) costs more gas (approximately 20,000 units per slot) than updating an existing slot [52]. Subsequent submissions by other clients in the same round require less gas, with each transaction using approximately 96,294 gas (see Table 3). This reduction in gas cost is due to the fact that the primary storage structures for the round have already been initialized within the same array. Each new client still initializes its own entries in the mappings (which also incurs some costs), but it avoids the higher costs associated with initializing the round’s storage structures. It is important to note that in EVM, storage slots are considered “cold” when they are accessed for the first time in a transaction and “warm” on subsequent accesses within the same transaction, as described in EIP-2929 [52]. However, since the submission of each client is a separate transaction, the storage slots for each transaction are “cold”. The lower gas costs are therefore not due to the EVM’s cache retaining data between transactions, but to the fact that less storage initialization is required.

3) Gas Used for Reputation Score Calculation
When analyzing gas usage in the smart contract reputationCalculation.sol, ten unique observations emerged that shed light on the functioning and underlying mechanisms of the contract. Since updateScores() is called when all 50 clients have submitted their local NMSEs, all NMSEs are stored together in the storage array nmseValues and the reputationScores are calculated for each client and updated accordingly. Round 1, which serves as the initialization round, takes place when the function updateScores() is called for the first time. It consumes 1,333,405 gas, as shown in Table 3. During this first call, all 50 entries in the reputationScores mapping and the nmseValues storage array are updated from their initial zero values to non-zero values. In contrast, subsequent rounds – from Round 2 onwards – stabilized between 458,481 and 458,577 gas, reflecting the lower cost of updating existing non-zero scores. The underlying data structures no longer require as many computational resources as when they were originally set up, as less energy is required to update this “warmer” data, which relates to data that has only recently been used and is therefore more readily accessible in the Ethereum state trie [53]. In the following rounds, a consistent pattern emerged: each new round showed a slight increase in gas usage by 12 gas. This subtle but telling difference was closely related to the gas cost associated with the transaction data payload. More specifically, each additional non-zero byte in the array of NMSE values increased the gas cost by 12 gas. This increase is due to the fact that a non-zero byte incurs a higher gas cost of 16 gas than a zero byte, which only costs 4 gas (see Table 3) [51].

D. Transaction Latency
In this section, we analyze the latency observed in various functions within the smart contract functions, as explained above with the parameters given in the Table 4.

TABLE 4 Summary of Main Smart Contracts and Their Key Functions
Table 4- Summary of Main Smart Contracts and Their Key Functions
1) Latency Observed for Registration of Clients
As already explained above in the workflow, registration in the FL DApp with registrationClient.sol is required. With registerAsClient() we register 50 clients sequentially on the FL DApp, which corresponds to the process explained in the work in [50]. The boxplot in Figure 3 shows the registration times for 50 blockchain clients and captures the latency spread and the central tendency. Most of the data points cluster tightly, which is reflected in the narrow interquartile range (IQR) and the median around 10s. This is largely due to Polygon’s use of L2, which processes transactions in batches off the congested Ethereum main chain, reducing transaction load and therefore latency. Despite the general uniformity of the transaction times, the figure also shows an outlier with a higher latency of 41.424s. A closer examination of the transaction that is part of block number 7908352 associated with this outlier reveals the underlying factors contributing to this anomaly. The block at height 7908352 contains 4 regular user-initiated transactions. These regular transactions included interactions with smart contracts. During the execution of these smart contract interactions, 2 additional internal transactions occurred. These internal transactions were of type create, which means that the contract(s) created or deployed another contract(s) as part of their execution. Internal transactions are not part of the block’s top-level transaction list, but are recorded in the transaction receipts as events that occur within the contract logic itself and may affect the overall latency observed at this point [51], [53].

FIGURE 3. - Latency for CLSPn registration ranging from 1-50.
FIGURE 3.
Latency for CLSPn registration ranging from 1-50.

Show All

Figure 4 shows the CDF of the registration latency and provides an overview of the latency distribution. The mean latency (9.624 seconds) is marked by a dashed line, which represents the average. The median (9.675 seconds) is marked by a dotted line, which represents the 50th percentile. The 95th percentile, represented by a blue dashed line, indicates that 95% of registration times are below this value, illustrating typical transaction delays. The CDF illustrates that while most transactions are processed quickly, a small proportion take significantly longer. This means that complex transactions within a block may result in internal transactions, or internal contract creation which may affect the overall performance of the block. While Polygon’s modified Proof of Stake (PoS) mechanism usually ensures efficient transaction processing, high transaction volumes or complex transactions can delay the creation and agreement of new checkpoints [54]. These factors have a temporary effect on the confirmation times of transactions and contribute to the fluctuations in latency shown in the boxplot. Finally, Figure 5 shows the histogram analysis of our registration, which reveals distinct patterns in three important metrics: block size, gas used, and transaction count. Block size (KB) shows a right-skewed distribution where most blocks are relatively small – the mean block size is 2.61 KB, well above the median of 1.50 KB. This skewness indicates the presence of large outliers, suggesting that while the blockchain often processes blocks with minimal data, occasional spikes process larger transaction volumes. This is consistent with the observed transaction count and follows a right-skewed distribution, albeit with a lower dispersion that shows a clear peak around the mean of 3.02 transactions per block. This pattern suggests that most blocks manage a similar, smaller number of transactions, while only a few blocks have a higher transaction volume. Finally, gas used (K) shows a right-skewed shape with a much larger dispersion compared to block size, illustrating the significant variability of gas consumption per transaction. A prominent peak in the lower gas usage range, where the mean value is 536.73 K and the median 193.27 K, indicates that many transactions are straightforward or involve fewer operations.

FIGURE 4. - CDF for CLSP registration ranging from 1-50.
FIGURE 4.
CDF for CLSP registration ranging from 1-50.

Show All

FIGURE 5. - Block data from the Transaction performed for registerAsClient() including registrationClient.sol Block Size (KB), Transaction Count per Block and Gas Used per Block with Gas Price of 1.50 Gwei ranging from Block Number 7906025 to 7908522.
FIGURE 5.
Block data from the Transaction performed for registerAsClient() including registrationClient.sol Block Size (KB), Transaction Count per Block and Gas Used per Block with Gas Price of 1.50 Gwei ranging from Block Number 7906025 to 7908522.

Show All

2) Latency Observed for Submission of Clients NMSE
We provide an analysis of the function submitNMSE() by all clients, where each client submits a pre-calculated NMSE value. These calculated values are computed off-chain and integrated into the smart contract performanceSubmission.sol deployed on our proposed FL DApp. All registered clients submit their precalculated NMSE values for 50 rounds simultaneously on the FL DApp using the function submitNMSE() in performanceSubmission.sol.

In Figure 6, we look at the analysis of latency in the transmission of NMSE values over a sequence of transaction rounds for fifty clients, labeled CLSP1 to CLSP50. This analysis is organized into three primary visual representations: a latency boxplot for each client in Figure 6, CDF graphs for selected accounts in Figure 7 and violin graphs in Figure 8 for the same subset of accounts. Each form of visualization provides different insights into latency characteristics and network performance during simultaneous operation. First, the grouped box diagram in Figure 6 illustrates the latency for all 50 accounts over 50 rounds of weight submissions. Each box represents an account (CLSPi) and reflects the central tendency and dispersion of latency. Despite the apparent increase in latency from CLSP1 to CLSP50, it is important to clarify that all accounts transmit their NMSE values concurrently. The term concurrently in this context refers to the simultaneous transmission of data [55] by multiple clients to the server through a smart contract, which is triggered by the function submitNMSE() to understand the overall performance of the network during peak loads. The voilin plot and the CDF further shows the latency for the selected CLSP.

FIGURE 6. - Latency for submitNMSE() for clients ranging from CLSP
$_{i}{=}1$
 to 50 during rounds.
FIGURE 6.
Latency for submitNMSE() for clients ranging from CLSPi=1 to 50 during rounds.

Show All

FIGURE 7. - CDF for clients NMSE submission 1, 10, 20, 30, 40, 50.
FIGURE 7.
CDF for clients NMSE submission 1, 10, 20, 30, 40, 50.

Show All

FIGURE 8. - Latency Observed for Selected Clients for submitNMSE().
FIGURE 8.
Latency Observed for Selected Clients for submitNMSE().

Show All

The three histograms shown in Figure 9 illustrate important metrics for blockchain operations during transactions processed by the submitNMSE() function. The first graph shows the distribution of block sizes, with most blocks being relatively small, as indicated by a peak just above 0 KB and a mean highlighted by a dashed blue line, showing that there are few instances of larger block sizes. The second graph shows transaction counts per block. It illustrates that most blocks contain only a few transactions, with a sharp decline observed above 5 transactions, indicating that higher transaction counts per block are uncommon. Finally, the third diagram shows the gas used per block. It shows a right-skewed distribution, with the majority of blocks consuming a minimal amount of gas and the mean value indicated by a dashed orange line, while outliers indicate occasional higher gas consumption. These graphs provide a comprehensive overview of the dynamics of the blockchain under certain gas price conditions.

FIGURE 9. - Block data from the Transaction performed for submitNMSE() in performanceSubmission.sol including Block Size (KB), Transaction Count per Block and Gas Used per Block when Gas Price ranges from 1.500000015 to 1.500000016 Gwei ranging from Block Number 8442988 to 8444219.
FIGURE 9.
Block data from the Transaction performed for submitNMSE() in performanceSubmission.sol including Block Size (KB), Transaction Count per Block and Gas Used per Block when Gas Price ranges from 1.500000015 to 1.500000016 Gwei ranging from Block Number 8442988 to 8444219.

Show All

The CDF plots in Figure 7 for selected accounts: CLSP1, CLSP10, CLSP20, CLSP30, CLSP40, and CLSP50 provide a probabilistic perspective on latency by quantifying the percentage of submissions that are completed within different timeframes. The rapid rise of the CDF curves at lower latencies and their plateau at the upper end illustrate the system for the majority of transactions, but also show a tail of longer delays. These longer delays are an indication of the problems of the system under conditions of high concurrency. In addition, the violin plots for the same selected accounts provide a more detailed exploration of the latency distributions. The comprehensive analysis in Figure 6 shows a pronounced linear trend of increasing latency as the number of concurrent client accounts increases, highlighting a critical scalability issue within the network. This trend is confirmed by both the CDF and the violin plots, where the mean and median are predominantly in the lower latency regions, while the 95th percentile is significantly higher, indicating significant delays at peak loads.

3) Latency Observed for Reputation Calculation
Figure 10 presents a boxplot and the CDF in Figure 11. The observed latency data provides valuable insights into the performance characteristics of our blockchain-based reputation system. The boxplot indicates that latencies cluster around 6.5 seconds, with most values ranging from approximately 6.2 to just over 7 seconds. A few outliers at around 9 and 10 seconds suggest occasional deviations. The CDF corroborates these findings: the mean latency is about 6.7 seconds, the median closely aligns with 6.5 seconds, and the 95th percentile stands at roughly 7.6 seconds. Taken together, these results indicate that the majority of latencies remain below 7.6 seconds, reflecting generally stable performance despite some sporadic increases.

FIGURE 10. - Box plot for 50 rounds of AGSP’s Reputation score Calculation.
FIGURE 10.
Box plot for 50 rounds of AGSP’s Reputation score Calculation.

Show All

FIGURE 11. - CDF for 50 rounds of AGSP’s Reputation Score Calculation.
FIGURE 11.
CDF for 50 rounds of AGSP’s Reputation Score Calculation.

Show All

These occasional spikes can be attributed to computationally intensive operations-specifically, the simultaneous execution of reputation calculations and top-performer selection. Instead of computing each reputation score individually, we integrate these tasks into a single transaction at the end of each round. This approach reduces the number of on-chain updates, thereby decreasing the overall overhead associated with gas costs and confirmation times. Each blockchain transaction entails a baseline expense; by batching computations, we effectively amortize these fixed costs over multiple operations, aligning with best practices in Ethereum and Polygon ecosystems [21], [56], [57]. For example, the 1inch protocol3 has demonstrated that such consolidation can lower total gas usage by 20–30%, lessening the per-operation burden and potentially improving confirmation times by easing network congestion [58].

Beyond cost efficiency, this consolidation can lead to more consistent latency characteristics. Even modest gains-such as a 15–25% reduction in median latency-have been observed when compared to processing each step in isolation [56], [57]. Moreover, synchronizing reputation scoring and top-performer selection ensures that ranking decisions are based on the most current data, enhancing data integrity and consistency. By reducing the complexity and frequency of state updates, we further mitigate the risks of errors or inconsistencies, ultimately fostering a more robust and reliable reputation system.

Finally, the histograms in Figure 12 show the distribution of block size, Transaction Count, gas consumption per block and gas price during a blockchain experiment. The block size is evenly distributed, as shown by the mean value, which is consistent with frequent values, suggesting stable block sizes. The transaction count histogram shows a skew towards fewer transactions per block, although occasionally higher numbers push the mean slightly above the mode. Gas used per block varies widely, with the mean being influenced by blocks that consume significantly more gas, highlighting outliers. Finally, the gas price shows a wide dispersion reflecting the variability of transaction costs, with the mean indicating the average price across different gas values. These histograms highlight the operational dynamics of the blockchain and provide insight into how block size, transaction volume and gas metrics affect system performance.

FIGURE 12. - Block data from the transactions performed for updateScore() in reputationCalculation.sol including Block Size (KB), Transaction Count per Block and Gas Used per Block when and Gas Price during experiment and Block Number ranging from 12926774 to 12926953.
FIGURE 12.
Block data from the transactions performed for updateScore() in reputationCalculation.sol including Block Size (KB), Transaction Count per Block and Gas Used per Block when and Gas Price during experiment and Block Number ranging from 12926774 to 12926953.

Show All

E. Discussion
We have presented both the architectural framework and the blockchain implementation for the integration of FL in O-RAN environments. Our approach leverages Polygon’s L2 solutions to create a DApp for managing and verifying ML model training and data exchanges in a multi-vendor environment for trusted collaborative learning. We present a Table 5 that gives a comprehensive overview of the blockchain parameters observed for each smart contract function in our implementation. The analyzed functions are registerAsClient(), submitNMSE() and updateScores(). For each function, we show the mean, standard deviation and median of the block size, total gas consumed in the block, transaction count, gas price and latency.

TABLE 5 Summary of Parameters for Smart Contract Functions
Table 5- Summary of Parameters for Smart Contract Functions
While our primary evaluation centered on CPU prediction, the proposed system naturally extends to Non-RT RIC tasks orchestrated by the SMO, which operate on larger timescales and prioritize strategic network optimization over low-latency execution. For instance, consider predictive maintenance for multi-vendor RAN infrastructure: the Non-RT RIC, co-located within the SMO, aggregates historical hardware telemetry (e.g., error logs, component lifespans) across distributed O-RUs and O-DUs [59]. FL enables vendors to collaboratively train failure-prediction models without exposing raw data, while Blockchain ensures accountability via smart contracts that validate data quality and incentivize honest participation. This approach allows operators to preemptively replace failing hardware, minimizing downtime-a use case explicitly aligned with O-RAN’s focus on AI/ML-driven fault detection [6], [49], [60]. Similarly, long-term network capacity planning [59] exemplifies how our framework supports secure collaboration under less time pressure. By analyzing traffic patterns and subscriber growth trends over weeks, the Non-RT RIC can forecast future resource demands (e.g., spectrum allocation, slice provisioning). FL models trained on multi-operator datasets enable vendors to optimize shared infrastructure investments, while Blockchain’s immutable ledger ensures transparent governance of data-sharing agreements. This is critical in O-RAN’s multi-stakeholder ecosystem, where operators must balance competition with cooperation. These scenarios underscore how our blockchain-enabled FL framework addresses challenges for various use cases.

Moreover, this study focuses on NMSE, our framework can be readily extended to accommodate other metrics such as energy consumption, processing time, or resource overhead. In particular, the design of the on-chain reputation mechanism allows for flexible integration of various performance indicators beyond NMSE. For instance, when energy efficiency or processing latency becomes critical in certain network scenarios, these parameters can be collected off-chain and incorporated into the reputation score calculation. By decoupling the local model performance metrics from the core blockchain logic, the framework remains adaptable to evolving O-RAN needs and diverse use cases, thus providing a more comprehensive view of system performance. We plan to explore these additional metrics in future research, with the goal of achieving a holistic assessment of FL in O-RAN environments.

Additionally, our proposed framework assumes a trust model that may not always be held in heterogeneous, multi-stakeholder environments. Although the blockchain-based reputation mechanism increases transparency, it does not inherently guarantee that all FL clients are fully trustworthy or free from adversarial behavior. A promising approach to strengthening trust and verification is Zero-Knowledge Machine Learning (ZK-ML) [61], which ensures that each component of the system executes algorithms correctly without revealing private data or intermediate states. In this context, the ZK-ML principles complement FL by enabling decentralized, privacy-preserving model training without explicit data exchange, offering uniform execution and enhanced threat protection. One notable implementation is the ezkl library, which transforms TensorFlow or PyTorch computational graphs into zero-knowledge proofs (ZK-SNARK circuits). Through these proofs, FL clients can cryptographically demonstrate the correctness of their computations on private data, bolstering trust and reliability in collaborative learning settings [62]. However, because ZK-ML entails added computational overhead and complexity, a comprehensive performance analysis and integration strategy lies beyond the scope of this paper. We highlight it as a future research direction, alongside ongoing efforts to mitigate concurrency-related blockchain bottlenecks. Together, these considerations represent important limitations of our current approach, as well as practical paths to further strengthen the trustworthiness and scalability of FL solutions.

Finally, while our current work primarily focuses on the conceptual integration of blockchain-based reputation within an O-RAN FL environment, we have gone beyond theory by deploying and testing our system on a live PoS testnet (Polygon). This allowed us to measure key on-chain parameters-such as gas usage, transaction latency, and concurrency overhead-under realistic conditions rather than purely simulated or private-blockchain settings. Such empirical evaluation demonstrates real-world feasibility and provides concrete data on performance constraints (e.g., gas costs, block sizes), aspects that are often overlooked in conceptual studies.

For example, in a multi-operator scenario, establishing trust is crucial for effective collaboration where FL enables different IT and network infrastructures to share critical operational insights-such as potential attacks or failure patterns-through a global model, here blockchain technology enforces trust and reliability among participants. By combining FL’s capacity for collective knowledge exchange with blockchain’s transparent and tamper-resistant ledger, operators can better safeguard their systems and ensure more resilient multi-operator environments.

In addition, by aligning our FL workflow and smart-contract architecture with O-RAN, our framework remains compatible with industry efforts that are increasingly exploring blockchain-based solutions for multi-operator resource management. Consequently, this research serves as both a proof-of-concept-leveraging real chain transactions-and a starting point for further standardization or operational integration, paving the way for greater scalability and adoption of blockchain-based FL solutions in O-RAN deployments. While Polygon is known to reduce latency through its off-chain transaction processing [63], our experimental results indicate that it faces notable performance bottlenecks under conditions of high concurrency [64]. This limitation underscores the ongoing need for infrastructure-level optimizations to meet the demanding requirements of FL, especially when many clients are training and updating models simultaneously.

SECTION V.Conclusion
This paper introduced a conceptual framework that integrates blockchain with Federated Learning (FL) to enhance trust, transparency, and coordination within O-RAN environments. By leveraging transaction batching and Layer 2 scaling techniques-approaches widely acknowledged for achieving up to a 20–30% reduction in gas overhead and delivering notable latency improvements-this framework is positioned to benefit as blockchain scalability continues to advance. The tests conducted on the Polygon testnet, particularly in Amoy, revealed important blockchain-related parameters such as gas usage, latency, transaction counts per block, gas used per block, and the block size. By testing our proposed smart contract in the FL environment, we demonstrate the potential and trade-offs. These findings are crucial for the further development of blockchain-based FL systems.

Nevertheless, our results show that high concurrency conditions can introduce performance bottlenecks, underscoring the need for further infrastructure-level optimizations to meet the demanding requirements of large-scale FL deployments. In addition, while the blockchain-based reputation mechanism promotes transparency, it assumes a trust model that may not always hold in heterogeneous, multi-stakeholder environments.

Future efforts will aim to optimize the smart contract to reduce gas consumption and latency during peak loads. We also plan to address concurrency-related challenges through more efficient blockchain configurations and further investigate privacy-enhancing techniques. In particular, integrating Zero-Knowledge Machine Learning (ZK-ML) can strengthen trust and confidentiality by enabling secure computation proofs without revealing sensitive data. We also plan to integrate Zero-Knowledge Machine Learning (ZK-ML) to improve privacy and reduce the computational load on the blockchain to improve O-RAN collaboration. We can also observe how specific blockchain parameters-such as gas price, transaction count, and block size– play critical roles in the cost-effectiveness of our reputation mechanism. For instance, higher gas prices may increase operational costs for frequent on-chain reputation updates, whereas elevated transaction counts can lead to network congestion and longer confirmation times. Similarly, block size limitations can constrain throughput, a key factor when large numbers of FL clients concurrently submit model updates or reputation scores. These findings highlight the importance of carefully tuning and monitoring these parameters to maintain an optimal balance between system performance and operational cost. In summary, these steps represent important avenues for improving both the performance and reliability of blockchain-based FL solutions in O-RAN, ensuring better performance even when numerous clients update models concurrently.